var Hapi = require('hapi')
var server = new Hapi.Server();
server.connection({ port: 3000 });
var io = require('socket.io')(server.listener);

// Setup basic index and static file server 

server.route({
	method: 'GET',
	path: '/',
	handler: function(request, reply) {
		reply.file(__dirname + '/index.html');
	}
});

server.route({
	method: 'GET',
	path: '/{param*}',
	handler: {
		directory: {
			path: __dirname
		}
	}
});

server.start(function() {
	console.log('Listening at: ', server.info.uri);
});

// The opposite of an edge
var MIRRORS = {
	'left' : 'right',
	'top' : 'bottom',
	'right': 'left',
	'bottom': 'top'
};

// World is a hash of objects indexed by socket.id (a unique identifier for each socket
// assigned by socket.io
// Each object in world is of the form
// {
//	'socket': {the socket object},
//	'left': {id of another socket we can lookup in table},
// 	'right': {id of another socket we can lookup in table},
//	'top': {id of another socket we can lookup in table},
//	'bottom': {id of another socket we can lookup in table},
//	'connections': {# attributes above that point to a socket other than the 'socket' referenced in this object}
// }
var world = {};

// This is the socket the dragon is currently floating around in
var dragonSocket = null;

// Boolean indicating the next person to connect will be the first, and we should initiate an 'entering' event to
// spawn the dragon on their screen
var isFirst = true;

// Returns a random integer between min (included) and max (excluded)
// Using Math.round() will give you a non-uniform distribution!
function getRandomInt(min, max) {
	// Thanks Mozilla https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
  	return Math.floor(Math.random() * (max - min)) + min;
}

// Unregister the user, and reset any connctions to them
function removeSocket(world, socket) {
	var connections = world[socket.id];
	for(d in MIRRORS){
		// If it is connected to a socket other than itself
		if(connections[d] !== socket.id) {
			// Replace that socket's attachement with an attachement to itself
			var otherSocketId = connections[d];
			world[otherSocketId][MIRRORS[d]] = otherSocketId;
			world[otherSocketId]['connections'] -= 1;
		}
	}

	// Remove from world
	delete world[socket.id]
}

// Insert a socket into the world object
// We insert it hashed by it's own id, a unique identifier generated by socket.io
//
// TODO:
// Someone connects, and many other people are connected
// We need an algorithm that finds where the user can insert themselves to make
// the most connections possible.
function insert(world, socket) {
	world[socket.id] = emptyLeaf(socket);

	// We only have 1 connections per edge of the screen 
	var MAXCONNECTIONS = 4;

	// For each socket in the world
	for(id in world){
		// Skip self
		if(id === socket.id){
			continue;
		}

		var otherConnections = world[id];

		// Ccheck if the socket has any open conncetions
		if(otherConnections['connections'] < MAXCONNECTIONS) {
			for(d in MIRRORS){
				// If it is still connected to itself on that direction
				if(otherConnections[d] === otherConnections['socket'].id) {
					// Connect this existing socket's edge to the new socket. This
					// Will be used to re-spawn the dragon into the new user's screen
					// if it exits on edge {d} of existing user's screen
					otherConnections[d] = socket.id;
					otherConnections['connections'] += 1;

					// Add a corresponding connection from the new user's screen, on the opposite
					// edge, back to the exisiting user.  They now have a bidirectional connection
					world[socket.id][MIRRORS[d]] = id;
					world[socket.id]['connections'] += 1;

					// Now that we've added a single connction, break out of the loop
					break;
				}
			}
		}
	}
}

// Create an empty leaf node for our world
// By default, all the edges of the object point back to
// the leaf's socket
function emptyLeaf(socket){
	var leaf = {
		'socket': socket,
		'left': socket.id,
		'right': socket.id,
		'bottom': socket.id,
		'top': socket.id,
		'connections': 0
	};

	return leaf;
}

// On connction, add the user to our world graph and spawn the dragon if they are the first to connect
io.on('connection', function(socket) {
	// Create an object for the user's socket and add to the world, indexed by socket.id.
	// If the user is the first to connect, it will only have directions that point to itself.
	insert(world, socket);

	//	Someone connects, and no one else is connected
	//  The dragon should spawn on their machine, and whenever it reaches the edge of their canvas
	//  re-spawn at the opposite edge (left<->right, top<->bottom)
	if(isFirst){
		isFirst = false;

		dragonSocket = socket;

		dragonSocket.emit('entering', {'direction': 'right'});
	}

	// When the dragon reaches that edge of a user's screen, the dragon is removed and the new
	// owner receives an event notifying them that the dragon appeared, and on which side
	// This causes the new owner's browser to render the dragon and give the user control of it.
	// For example, if user A's left edge is connected to user B, we emit
	// an 'entering' event to B when the dragon exits the left side of A's screen,
	// with a direction of 'right'.
	socket.on('leaving', function(data){
		// Make sure the data we get is in our hash
		if(MIRRORS[data.direction]){
			var connections = world[socket.id];

			dragonSocket = world[connections[data.direction]]['socket'];

			dragonSocket.emit('entering', {'direction': MIRRORS[data.direction]});

			console.log("Entering " + MIRRORS[data.direction]);
		}
	});

	// A user closes the tab, ending the session
	socket.on('disconnect', function() {
		// A user disconnects while they don't have the dragon
		// The user should is unregistered, and any edges that are connected to other people
		// are removed from the other person's edge as well
		removeSocket(world, socket);

		console.log('Removed ' + socket.id);

		console.log(world);

		// A user disconnects while they have the dragon
		// The dragon should be re-assigned to a random user coming from the middle right
		// The user should be unregistered as described in Scenario C
		if(socket === dragonSocket){

			var remainingSockets = [];

			for(var s in world) remainingSockets.push(s);

			if(!remainingSockets.length === 0){
				var newSocketIndex = getRandomInt(0, remainingSockets.length);

				dragonSocket = world[remainingSockets[newSocketIndex]]['socket'];

				dragonSocket.emit('entering', {'direction': 'right'});
			} else {
				// A user disconnects and there are no other users are connected
				// The dragon dies, and is reborn when then next user connects to the screen.
				isFirst = true;
			}
		}
	});
});
